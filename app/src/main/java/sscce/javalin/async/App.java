/*
 * This Java source file was generated by the Gradle 'init' task.
 */

package sscce.javalin.async;

import io.javalin.Javalin;
import io.javalin.http.HandlerType;
import org.apache.activemq.artemis.api.core.TransportConfiguration;
import org.apache.activemq.artemis.api.core.client.*;
import sscce.javalin.async.msg.ConsumerSession;
import sscce.javalin.async.msg.JsonUtil;
import sscce.javalin.async.msg.MessageBroker;
import sscce.javalin.async.msg.ProducerSession;
import sscce.javalin.async.msg.Request;
import sscce.javalin.async.util.FakeWork;

import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicLong;

import static io.javalin.Javalin.create;

public class App implements MessageHandler {
    public static final String RESPONSE_QUEUE = "app.response";
    // used to get a unique id for each request
    private static final AtomicLong requestCounter = new AtomicLong(0);
    // the 'worker' that does async work for the /dispatched route
    private final DispatchedWorker worker;
    // map of pending http response futures, keyed on unique request id
    Map<String, CompletableFuture<String>> pendingResponses = new ConcurrentHashMap<>();
    // instance of embedded activemq broker
    MessageBroker broker;
    // server
    Javalin javalin;
    // executor used for async runnables used in javalin request handlers
    private final ExecutorService executor = Executors.newCachedThreadPool();

    // stuff for establishing the message channel
    private final ClientSessionFactory clientSessionFactory;
    private final ConsumerSession consumerSession;
    // just here to for SSCCE, real impl uses pools for this.  Session creation isn't cheap, but should suffice
    // if we're warming up the JVM before collecting metrics.
    private ThreadLocal<ProducerSession> prodSession;

    public App() {
        broker = new MessageBroker();
        ServerLocator locator = ActiveMQClient.createServerLocator(
            false,
            new TransportConfiguration("org.apache.activemq.artemis.core.remoting.impl.invm.InVMConnectorFactory")
        );

        try {
            clientSessionFactory = locator.createSessionFactory();
            consumerSession = new ConsumerSession(clientSessionFactory, RESPONSE_QUEUE, this);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }

        javalin = create(config -> {
            config.http.asyncTimeout = 10_000;
        });
        addHandlers();
        worker = new DispatchedWorker();
    }

    public static void main(String[] args) {
        App app = new App();
        app.start();
        Runtime.getRuntime().addShutdownHook(new Thread(app::stop));
    }

    /**
     * Handles messages sent to queue with name/address {@link App#RESPONSE_QUEUE}
     */
    @Override
    public void onMessage(ClientMessage message) {
        try {
            var body = message.getBodyBuffer().readString();
            var res = JsonUtil.toResponse(body);
            var requestId = res.id;
            pendingResponses.remove(requestId).complete(res.content);
        } catch (Exception e) {
            throw new RuntimeException("Failed handling response message.", e);
        }
    }

    private void addHandlers() {
        if (javalin != null) {
            javalin.addHandler(HandlerType.GET, "/simple", ctx -> {
                ctx.future(() -> {
                    String requestId = Long.toString(requestCounter.incrementAndGet());
                    CompletableFuture<String> future = new CompletableFuture<>();
                    CompletableFuture.runAsync(() -> {
                        var randomString = FakeWork.work(20000);
                        future.complete(randomString);
                    }, executor); // have also tried passing in my own executors

                    return future.thenAccept(ctx::result);
                });
            });

            javalin.addHandler(HandlerType.GET, "/dispatched", ctx -> {
                ctx.future(() -> {
                    String requestId = Long.toString(requestCounter.incrementAndGet());
                    CompletableFuture<String> future = new CompletableFuture<>();
                    pendingResponses.put(requestId, future);

                    CompletableFuture.runAsync(() -> {
                        // build request proxy
                        Request req = new Request(requestId);
                        // fire request proxy on message channel, will be completed by onMessage following message
                        // dispatch from 'DispatchedWorker'
                        try {
                            dispatchReqEvent(req);
                        } catch (Exception e) {
                            throw new RuntimeException(e);
                        }
                    }, executor);

                    return future.thenAccept((String str) -> {
                        ctx.json(str).status(200);
                    });
                });
            });
        }
        ;
    }


    public void start() {
        if (consumerSession != null) consumerSession.start();
        javalin.start(7070);
    }

    public void stop() {
        javalin.stop();
        clientSessionFactory.close();
        clientSessionFactory.cleanup();
        if (worker != null) {
            worker.stop();
        }
    }

    private void dispatchReqEvent(Request reqEvent) throws Exception {
        if (this.prodSession == null) {
            // lazily build a threadlocal session if one doesn't exist.  Not a real-workd implementation, but should
            // suffice for the SSCCE on a warmed jvm.  Real impl uses appropriate pooling mechanisms.
            this.prodSession = ThreadLocal.withInitial(
                () -> new ProducerSession(clientSessionFactory, DispatchedWorker.INCOMING_QUEUE)
            );

        }
        CompletableFuture.runAsync(() -> {
            try {
                ProducerSession msgSession = prodSession.get();
                var reqEventJson = JsonUtil.toJson(reqEvent);
                var msg = msgSession.createMessage();
                msg.setAddress(DispatchedWorker.INCOMING_QUEUE);
                msg.getBodyBuffer().writeString(reqEventJson);
                msgSession.producer.send(msg);
                msgSession.session.commit();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        });
    }
}
